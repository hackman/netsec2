% Сложност и изчислимост
% и практическото им приложение в протоколите за комуникация
% Vasil Kolev \<vasil@ludost.net\>

# Сложност

## Механизми за обработка
### Описание

* Краен автомат
* Стеков автомат
* Turing-complete

<!--
За обработка на различни типове протоколи/формати имаме в общи линии
три абстракции, които можем дам ползваме - краен автомат, стеков автомат
и машина на Тюринг.
-->
### Краен автомат

* (сравнително) лесен за конструкция
* възможен за валидация
* ограничен като възможности

<!--
Крайните автомати са най-простата възможна конструкция, която в някакви
размери е възможна за валидация, но е ограничена като възможности. Един
пример за крайни автомати са нормалните регулярни изрази (не тези в perl,
където има допълнителни добавки).

В общи линии протокол, който използва специфичен разделител между различните
си полета може да се обработва с краен автомат. 
FIXME протокол с разделители и \, например
-->

### Стеков автомат

* по-сложен за конструкция
* с повече възможности
* вложени структури (json, XML)
* type-length-value схеми
    * повечето мрежови протоколи го използват
* Примерен проблем - http://heartbleed.com/

<!--
Стековите автомати са по-сложни и се използват за протоколи, в които
може да има влагане на различни елементи. Много познати протоколи (като
XML, JSON) се обработват със стекови автомати, както и схемите от типа
type-length-value, които са повечето мрежови протоколи.

Тези автомати са по-сложни за писане и съответно по-сложни за валидация,
което води до доста грешки в тях. Може да се каже, че този тип автомати,
заедно с memory management проблемите в C/C++ са един от най-големите
източници на пробиви в сигурността на софтуера.

Пример за тривиална атака върху такъв недомислен автомат е да направите
пакет, в който имате тип, дължина, която е по-голяма от самия пакет и 
някакви данни, което при неправилно направен автомат/parser ще доведе
до четене на данни извън пакета и странно поведение на програмата. За
такъв проблем може да видите Heartbleed.
FIXME може би да обясня какво точно представляваше
-->

### Turing complete автомат

* това, което ни е познато като "компютърна програма"
* практически невъзможен за валидация
    * супер-експоненциално, 2^p^, p=2^x^
* всички програмни езици (които трябва да са такива)
* разни неща, които не трябва
    * HTML5+CSS3

<!--
Машините на Тюринг, въпреки че са нещо наистина мощно и удобно и са
основата на информатиката, която познавам, представляват и един 
сериозен проблем от гледна точка на сигурността.

Според някои основни теореми, много е трудно да се докаже някакво
специфично поведение на машина на Тюринг, използвайки друга машина
на Тюринг, т.е. проверката на верността на всяка такава машина трябва
да се прави на ръка. Съществуващите методи за това (ако изобщо се ползват)
са супер-експоненциални

-->

### А какво ползваме ние?

* Реално погледнато - машини на Тюринг
* Всеки автомат, който има странични ефекти (заделяне на памет например) е такъв
* Още по-сложно да се валидира един такъв parser


<!--
Въпреки, че имаме по-прости конструкции, това, което най-често се среща
в кода е машина на Тюринг, най-вече защото за програмистите е по-лесно.
Дори където имаме краен или стеков автомат, много често в кода имаме т.нар.
"странични ефекти", които водят до превръщането на автомата в машина на Тюринг
и до всякакви неприятни последици.

Накратко, мъка.
-->
## Последици за нас

### Последици 1/2

* Невъзможност за сигурна обработка на някои
    * Turing-complete нещата
* Огромно количество security проблеми
* Тотално неразбиране на идеята за валидация
* Shotgun-type валидациа

<!--
Това води до много несигурни и опасни parser-и. Някои от тях няма начин на
практика да се валидират, някои (които обработват Turing-complete неща) реално
нямат как да валидират това, което проверяват, и това ни води до настина
много проблеми.

Това идва от неразбирането на идеята за валидация, защото хората предпочитат
да мислят, че входните им данни винаги са валидни, и просто добавят по някоя
друга проверка за случаи, които им хрумват. Това води до т.нар. shotgun-type
валидация, т.е. какво би се случило, ако си разпечатате кода на листи, лепнете
го на стената и стрелята от далече по него с пушка със съчми, и където падне
някоя съчма - слагате проверка...
-->

### Последици 2/2 (weird machines)

* Много неща се оказват по странен начин Turing-complete
* Вероятно може да напишете нещо с HTML5+CSS3, което смята bitcoin
    * (забележете, без javascript)
* 

### Решения

* По-прости протоколи
* Автоматично генерирани parser-и/валидатори


<!--
Проблемът почти има решение.

Първо, може да се мислят/правят протоколи с по-ниска сложност, доколкото е
възможно, т.е. които и лесно могат да се parse-нат, с по-малко неясноти в
тях и като цяло колкото се може по-малки, понеже колкото по-малко код се налага
да пишете, толкова по-малко грешки могат да се допуснат.

Друго нещо, което може (и трябва) да се прави е да се ползват автоматични
инструменти за генерирането на parser-и и валидатори. Има едно количество
такива, които от зададена формално граматика в някакъв вид могат да генерират
код, който да я parse-ва и валидира. Доста от тях са формално доказани (или
наистина много добре тествани) и могат да се ползва спокойно.
FIXME примерни инструменти и дали трябва да се говори още малко
FIXME практически неща?
-->

## Недомислена изчислителна сложност

### Хешове

* Каква е сложността за добавяне на елемент в хеш?
     * o(n) = log~b~(n) (b - брой bucket-и)
     * обаче, O(n) = n

* Практическо следствие - n.runs-SA-2011.004
http://archives.neohapsis.com/archives/bugtraq/2011-12/0181.html


