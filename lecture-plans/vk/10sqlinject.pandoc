% SQL injection
% или какво-прави-тая-кавичка-тука
% Vasil Kolev \<vasil@ludost.net\>

# SQL injection
## SQL
### Описание

* Език за разговори с бази данни
* SELECT user, password FORM users WHERE username='admin'
* Почти истински език за програмиране

<!--
SQL е език за програмиране, който се използва за комуникация с бази данни. В наши дни основно се генерира от други програми, за да се извлече или работи в/у някаква информация в базата.
-->

### Употреба

* Почти всички бази данни
    * MySQL
    * PostgreSQL
    * Oracle
    * Microsoft SQL server
    * ...
* От повечето езици за програмиране

<!--
Използва се при работата с повечето бази данни, които може да намерите по света и които са наистина бази данни. Има поддръжка за него в някакъв вид и в почти всички програмни езици.
-->

## Атаки

### Пример

~~~~~~PHP
# НИКОГА не пишете такъв код
$user = $_GET['user'];
$pass = $_GET['pass'];

$res = mysql_query("SELECT count(*) FROM users "\
"WHERE username='".$user"' AND pass='".$pass."';");
~~~~~~

<!--
Ето как да не пишете код. Накратко, взимат се два параметъра и се сипват директно в заявката, която се изпълнява.
-->

### нормално изпълнение
~~~~~~PHP
$user="admin";
$pass="tmp";
~~~~~~
~~~~~~SQL
  SELECT count(*) FROM users
  WHERE username='admin' AND pass='tmp';
~~~~~~

<!--
При нормално изпълнение заявката би трябвало да изглежда така, с нормално заместени user и парола.
-->

### по-весело изпълнение
~~~~~~PHP
$user="admin";
$pass="' OR ''='";
~~~~~~
~~~~~~SQL
  SELECT count(*) FROM users 
  WHERE username='admin' AND pass='' OR ''='';
~~~~~~

<!--
Може и да е по-забавно - можем да сложим още малко кавички в единия параметър, и заявката се променя, вместо да броя редове, в които има този потребител и парола, то ще избере всички редове в таблицата (с малко допипване може да избере и точно един).
-->

### и леко тъжно такова
~~~~~~PHP
$user="admin";
$pass="'; DROP table users;\n --";
~~~~~~
~~~~~~SQL
  SELECT count(*) FROM users
  WHERE username='admin' AND pass='tmp';
  DROP table users;--'
~~~~~~

<!--
... или просто може да изтрие таблицата с потребителите.
-->

### little Bobby tables
![exploits_of_a_mom](exploits_of_a_mom.png)

<!--
Това vulnerability е толкова познато и известно, че даже има комикси
с него.

Само да отбележа - примерите по-горе не са съвсем директно работещи, и за всяка база си има специфики на атакуване, при някои работят няколко заявки, разделени с ;, при някои не и т.н., това винаги има нужда да се изтества, ако реализирате истинска атака. (т.е. повече се притесняваме, ако правите некадърни атаки, отколкото ако правите атаки)
-->

## Защо е възможно

### Как може да има такива неща?

* Смесица на два езика с различни правила
* Липса на мисъл за какво има във входните данни
* Специални символи

<!--
Това е възможно, понеже реално имаме смесица на два езика с различни правила и реално през някакъв интерфейс създаваме (кофти) програма на другия език. 

Също така е възможно, понеже всички символи са равни, но някои са по-равни, съответно никой не очаква, че може да има нещо лошо във входните данни и че може да създаде проблем.
-->

### Специални символи

* Единична кавичка '
* Двойна кавичка "
* Коментар --
* Точка и запетая ;
* Нов ред \\n
* backslash \\

<!--
Това са в общи линии символите, които могат да създадат проблем.
-->

## Решения

### филтрация

* Изтриване на всички съмнителни символи
* Понякога са валидни!

<!--
Първия стандартен метод е просто да изтрием символите, които не ни харесват. Това може да свърши работа, ако сме сигурни кои са, и ако знаем, че няма да повредят данните.
-->
### escape

* Най-най-най простото решение:
* Добавяне на \\ пред всички специални символи

<!--
Вторият се базира на механизма за escape-ване на символи - т.е. ако подадем на базата \', то ще бъде прието като нормален string и няма да затвори string-а и няма да ни се получи атаката.
-->


### защо предните два метода не са добра идея

* Защото базата знае по-добре от вас какво трябва да се escape-не/филтрира
* Използвайте нейните функции!

~~~~~~PHP
$user = mysql_real_escape_string($_GET['user'], $c);
$pass = mysql_real_escape_string($_GET['pass'], $c);

$res = mysql_query("SELECT count(*) FROM users "\
"WHERE username='".$user"' AND pass='".$pass."';", $c);
~~~~~~

<!--
Предните два метода не са добра идея, понеже е трудно да сме сигурни кои точно символи трябва да се escape-ват и как точно. За целта винаги препоръчваме да използвате стандартните съществуващи функции за целта. Примерът, който съм дал е със старото PHP api, за новото може да прочетете в документацията.
-->

### Prepared statements

* Зависи от езика, но:

~~~~~~PHP
$stmt = $c->prepare("SELECT COUNT(*) FROM users \
            WHERE username=:u AND pass=:p");
$stmt->bindParam(':u', $user);
$stmt->bindParam(':p', $pass);
$res = $stmt->execute();
~~~~~~

<!--
Има и друг начин, който е по-труден за объркване - да се използват prepared statements. Идеята е, че може да прекомпилирате заявката, след което само  да и подавате параметри (които са на местата на т.нар. placeholder-и, в случая :p и :u). Така данните не се виждат като части от заявката, а като отделнипараметри и няма начин да изтекат в кода.

Това също така ви дава някакво по-добро бързодействие, ако изпълнявате много пъти една такава заявка, просто с различни параметри, понеже компилирането и се случва само веднъж.
-->

### ORM

* Object-relation mapping
* В общи линии езика се грижи да ви пише заявките
* Не-особено-гъвкаво, но върши работа
* Дават ви понякога възможност да си пишете сами заявки
    * където може спокойно да се простреляте в крака
* Не escape-ват нещата в order by (по дизайн!)
    * пример http://rails-sqli.org/#order

<!--
И метод, който става все по-"модерен" - object-relational mapping, в който просто имате обекти, които са свързани с базата данни и си говорите директно с тях, а framework-а под тях превежда заявките.

Разбира се, авторите на ORM-а може да са идиоти и да не са избегнали тези атаки, т.е. да не си проверяват данните и да позволяват SQL injection, но в общия случай по-известните и използвани ORM-и са написани сравнително правилно, съответно не са (особено) опасни.

Също така ORM-ите понякога дават възможност да си пишете сами заявките, съответно така може да си напишете сами sql injection по стандартния начин. Освен това, при ORM-ите, които сглабят заявки някои части не се escape-ват, например ORDER BY клаузите (понеже там няма начин ORM-а да знае какво точно вършите).

-->
